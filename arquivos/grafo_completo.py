# -*- coding: utf-8 -*-
"""GRAFO_COMPLETO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yLrZDpwJLabxn6edL5mlKkrMDH9MTido

# Exemplo completo de Grafos

Biblioteca
"""

from flask import Flask, url_for,render_template,request, redirect, session, Blueprint, flash, jsonify
import arquivos.ArvoreB.BTreeBiblioteca as bt

from igraph import *
import pandas as pd
import json
import os

ARQUIVO_VOOS = "arquivos/voos.json"


def MapaRotas():
    # Esta função original foi mantida, mas não é necessária para a RotaMaisBarata.
    # Ela apenas carrega os dados.
    if os.path.exists(ARQUIVO_VOOS):
                with open(ARQUIVO_VOOS, "r") as arquivoJson:
                    voosDoArquivo = json.load(arquivoJson)

    else:
        return None
    

    voosDoArquivo# CADA VOO DO ARQUIVO EQUIVALE A UM VERTICE, DEVE-SE CRIAR ROTAS POR DISTANCIA MINIMA E 
                 # POR MENOR PRECO USANDO OS VOOS DO ARQUIVO


# ==============================================================================
# FUNÇÃO 1: RotaMaisBarata (Mantida do pedido anterior)
# ==============================================================================

def RotaMaisBarata(origem_cidade, destino_cidade):
    """
    Gera o grafo da rota mais barata (menor preço) entre a cidade de origem e destino.
    Utiliza o algoritmo de caminho mínimo (Dijkstra) com o preço como peso.
    """
    
    # 1. Carregar os dados dos voos
    if not os.path.exists(ARQUIVO_VOOS):
        print(f"Erro: Arquivo de voos não encontrado em {ARQUIVO_VOOS}")
        return None, "Arquivo de voos não encontrado."
    
    with open(ARQUIVO_VOOS, "r") as arquivoJson:
        try:
            voosDoArquivo = json.load(arquivoJson)
        except json.JSONDecodeError:
            print("Erro: Arquivo JSON de voos inválido.")
            return None, "Arquivo de voos inválido."

    if not voosDoArquivo:
        return None, "Nenhum voo encontrado no arquivo."

    # 2. Mapear cidades (vértices) e preparar arestas
    cidades = set()
    arestas_com_peso = []

    for codigo, voo in voosDoArquivo.items():
        try:
            # Peso é o 'preco'
            peso = float(voo.get('preco', 0))
            origem = voo['origem'].strip()
            destino = voo['destino'].strip()

            cidades.add(origem)
            cidades.add(destino)
            
            # (origem, destino, peso)
            arestas_com_peso.append((origem, destino, peso))
        
        except ValueError:
            print(f"Aviso: Voo {codigo} com preço inválido, ignorado.")
            continue
        except KeyError as e:
            print(f"Aviso: Voo {codigo} com chave faltante: {e}, ignorado.")
            continue

    if not cidades:
        return None, "Nenhuma cidade válida para construir o grafo."

    # Mapeamento de nome da cidade para ID do vértice
    cidade_para_id = {cidade: i for i, cidade in enumerate(sorted(list(cidades)))}
    
    # Verificar se a origem e o destino existem no grafo
    if origem_cidade not in cidade_para_id or destino_cidade not in cidade_para_id:
        msg = f"Origem ('{origem_cidade}') ou Destino ('{destino_cidade}') não encontrados nos dados dos voos."
        return None, msg

    origem_id = cidade_para_id[origem_cidade]
    destino_id = cidade_para_id[destino_cidade]

    # 3. Criar o grafo
    g = Graph(directed=True)
    g.add_vertices(len(cidades))
    g.vs["label"] = sorted(list(cidades))
    
    # Adicionar as arestas com o preço como peso
    arestas_igraph = []
    pesos = []
    
    for origem_nome, destino_nome, peso in arestas_com_peso:
        u = cidade_para_id[origem_nome]
        v = cidade_para_id[destino_nome]
        arestas_igraph.append((u, v))
        pesos.append(peso)
        
    g.add_edges(arestas_igraph)
    g.es['weight'] = pesos
    g.es['label'] = [f"R$ {w:.2f}" for w in pesos]


    # 4. Encontrar o caminho mais barato (menor peso/preço)
    shortest_paths_info = g.get_shortest_paths(
        source=origem_id, 
        target=destino_id, 
        weights='weight', 
        output='epath' # Retorna os índices das arestas no caminho
    )
    
    # Se a lista de caminhos de arestas estiver vazia, não há rota
    if not shortest_paths_info or not shortest_paths_info[0]:
        msg = f"Não há rota disponível de {origem_cidade} para {destino_cidade}."
        return None, msg
        
    
    path_edge_indices = shortest_paths_info[0] # Índices das arestas do caminho mais curto
    total_cost = sum(g.es[i]['weight'] for i in path_edge_indices)
    
    # 5. Visualizar o grafo com a rota destacada
    
    out_name = f"rota_mais_barata_{origem_cidade}_para_{destino_cidade}.png"
    
    # Configurações visuais
    visual_style = {}
    visual_style["bbox"] = (800, 800)
    visual_style["margin"] = 50
    visual_style["vertex_size"] = 25
    visual_style["vertex_label_size"] = 14
    visual_style["edge_curved"] = 0.2
    
    # Cores e tamanhos dos vértices/arestas
    g.vs["color"] = "lightblue"
    g.es["color"] = "gray"
    g.es["width"] = 1.0

    # Destacar a origem e o destino
    g.vs[origem_id]["color"] = "red"
    g.vs[destino_id]["color"] = "green"

    # Destacar as arestas da rota mais barata
    for edge_index in path_edge_indices:
        g.es[edge_index]["color"] = "darkred"
        g.es[edge_index]["width"] = 2.5
        g.es[edge_index]["label_color"] = "darkred"

    # Adicionar o custo total ao label do grafo
    graph_title = f"Rota Mais Barata: {origem_cidade} -> {destino_cidade} (Custo Total: R$ {total_cost:.2f})"
    
    try:
        plot(g, target=out_name, **visual_style, caption=graph_title)
        return out_name, f"Rota encontrada com sucesso! Custo total: R$ {total_cost:.2f}"
    except Exception as e:
        print(f"Erro ao plotar o grafo: {e}")
        return None, f"Rota encontrada, mas erro ao gerar a imagem: {e}"


# ==============================================================================
# FUNÇÃO 2: RotaMenorTempo (Nova função solicitada)
# ==============================================================================

def RotaMenorTempo(origem_cidade, destino_cidade):
    """
    Gera o grafo da rota com o menor tempo total entre a cidade de origem e destino.
    Utiliza o algoritmo de caminho mínimo (Dijkstra) com o campo 'tempo' como peso.
    """
    
    # 1. Carregar os dados dos voos
    if not os.path.exists(ARQUIVO_VOOS):
        print(f"Erro: Arquivo de voos não encontrado em {ARQUIVO_VOOS}")
        return None, "Arquivo de voos não encontrado."
    
    with open(ARQUIVO_VOOS, "r") as arquivoJson:
        try:
            voosDoArquivo = json.load(arquivoJson)
        except json.JSONDecodeError:
            print("Erro: Arquivo JSON de voos inválido.")
            return None, "Arquivo de voos inválido."

    if not voosDoArquivo:
        return None, "Nenhum voo encontrado no arquivo."

    # 2. Mapear cidades (vértices) e preparar arestas
    cidades = set()
    arestas_com_peso = []

    for codigo, voo in voosDoArquivo.items():
        try:
            # Peso é o 'tempo'
            peso = float(voo.get('tempo', 0)) # Assumindo que 0 é o default para tempo inválido
            origem = voo['origem'].strip()
            destino = voo['destino'].strip()

            cidades.add(origem)
            cidades.add(destino)
            
            # (origem, destino, peso - tempo)
            arestas_com_peso.append((origem, destino, peso))
        
        except ValueError:
            print(f"Aviso: Voo {codigo} com tempo inválido, ignorado.")
            continue
        except KeyError as e:
            print(f"Aviso: Voo {codigo} com chave faltante: {e}, ignorado.")
            continue

    if not cidades:
        return None, "Nenhuma cidade válida para construir o grafo."

    # Mapeamento de nome da cidade para ID do vértice
    cidade_para_id = {cidade: i for i, cidade in enumerate(sorted(list(cidades)))}
    
    # Verificar se a origem e o destino existem no grafo
    if origem_cidade not in cidade_para_id or destino_cidade not in cidade_para_id:
        msg = f"Origem ('{origem_cidade}') ou Destino ('{destino_cidade}') não encontrados nos dados dos voos."
        return None, msg

    origem_id = cidade_para_id[origem_cidade]
    destino_id = cidade_para_id[destino_cidade]

    # 3. Criar o grafo
    g = Graph(directed=True)
    g.add_vertices(len(cidades))
    g.vs["label"] = sorted(list(cidades))
    
    # Adicionar as arestas com o tempo como peso
    arestas_igraph = []
    pesos = []
    
    for origem_nome, destino_nome, peso in arestas_com_peso:
        u = cidade_para_id[origem_nome]
        v = cidade_para_id[destino_nome]
        arestas_igraph.append((u, v))
        pesos.append(peso)
        
    g.add_edges(arestas_igraph)
    g.es['weight'] = pesos
    g.es['label'] = [f"{w:.0f}h" for w in pesos] # Rótulo em horas (assumindo que 'tempo' está em horas)


    # 4. Encontrar o caminho de menor tempo
    shortest_paths_info = g.get_shortest_paths(
        source=origem_id, 
        target=destino_id, 
        weights='weight', 
        output='epath' # Retorna os índices das arestas no caminho
    )
    
    # Se a lista de caminhos de arestas estiver vazia, não há rota
    if not shortest_paths_info or not shortest_paths_info[0]:
        msg = f"Não há rota disponível de {origem_cidade} para {destino_cidade}."
        return None, msg
        
    
    path_edge_indices = shortest_paths_info[0] # Índices das arestas do caminho mais curto
    total_time = sum(g.es[i]['weight'] for i in path_edge_indices)
    
    # 5. Visualizar o grafo com a rota destacada
    
    out_name = f"rota_menor_tempo_{origem_cidade}_para_{destino_cidade}.png"
    
    # Configurações visuais
    visual_style = {}
    visual_style["bbox"] = (800, 800)
    visual_style["margin"] = 50
    visual_style["vertex_size"] = 25
    visual_style["vertex_label_size"] = 14
    visual_style["edge_curved"] = 0.2
    
    # Cores e tamanhos dos vértices/arestas
    g.vs["color"] = "lightblue"
    g.es["color"] = "gray"
    g.es["width"] = 1.0

    # Destacar a origem e o destino
    g.vs[origem_id]["color"] = "darkorange" # Usando outra cor para diferenciar
    g.vs[destino_id]["color"] = "purple"

    # Destacar as arestas da rota mais rápida
    for edge_index in path_edge_indices:
        g.es[edge_index]["color"] = "darkgreen" # Cor verde escura para tempo
        g.es[edge_index]["width"] = 2.5
        g.es[edge_index]["label_color"] = "darkgreen"

    # Adicionar o tempo total ao label do grafo
    graph_title = f"Rota Menor Tempo: {origem_cidade} -> {destino_cidade} (Tempo Total: {total_time:.0f}h)"
    
    try:
        plot(g, target=out_name, **visual_style, caption=graph_title)
        return out_name, f"Rota encontrada com sucesso! Tempo total: {total_time:.0f} horas"
    except Exception as e:
        print(f"Erro ao plotar o grafo: {e}")
        return None, f"Rota encontrada, mas erro ao gerar a imagem: {e}"


